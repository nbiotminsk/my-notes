
# Чтение текущих параметров с теплосчетчика ТЭМ-104

Для считывания мгновенных (текущих) значений с теплосчетчика ТЭМ-104 используется команда `0C01h`, которая обращается к оперативной памяти прибора.

## Общий принцип

1.  Формируется посылка (запрос) к прибору с командой `0C01h` для чтения оперативной памяти.
2.  В запросе указывается начальный адрес в оперативной памяти и длина считываемого блока данных.
3.  Прибор возвращает ответ, содержащий запрошенные данные.

Все текущие параметры по системам хранятся в структурах `SysPar` (по одной на каждую систему).

## Адреса основных параметров в оперативной памяти

Ниже представлена таблица со смещениями (адресами) для запроса интересующих параметров внутри структуры `SysPar`.

| Параметр | Смещение (HEX) | Тип данных | Описание из документации | Единицы |
| :--- | :--- | :--- | :--- | :--- |
| **Температуры (T1, T2...)** | `0000` | `F[4]` | Текущие значения температуры по каналам | °C |
| **Объемный расход** | `0040` | `F[4]` | Текущие значения объемного расхода | м³/ч |
| **Массовый расход** | `0050` | `F[4]` | Текущие значения массового расхода | т/ч |
| **Тепловая мощность** | `0060` | `F[4]` | Текущие значения мощности | Гкал/ч |

*Тип данных `F[4]` означает массив чисел с плавающей запятой (float), по одному значению на каждый канал/систему.*

### Примечание по интеграторам (накопленным значениям)

Важно отметить, что **общий объем (V)** и **суммарное количество теплоты (Q, Гкал)** являются накопленными значениями (интеграторами), а не текущими. Они хранятся в другой области памяти и считываются из карты накопленных значений (см. п. 5.1.6 в документации, адреса `0008` для объема и `0028` для энергии).

## Пример на Python

Этот код демонстрирует, как сформировать пакет запроса для чтения данных из оперативной памяти. **Логика проверена и соответствует рабочей реализации.**

```python
import struct

def calculate_checksum(packet: list[int]) -> int:
    """Рассчитывает контрольную сумму как NOT(сумма всех байт)."""
    # & 0xFF гарантирует, что мы работаем с байтом
    return (~sum(packet)) & 0xFF 

def create_read_request(device_address: int, start_address: int, read_length: int) -> bytes:
    """
    Формирует пакет запроса для чтения оперативной памяти (команда 0C01h).

    :param device_address: Сетевой адрес прибора (1-32).
    :param start_address: Начальный адрес для чтения.
    :param read_length: Количество байт для чтения (1-112).
    :return: Готовый пакет в виде байтовой строки.
    """
    if not (1 <= device_address <= 32):
        raise ValueError("Сетевой адрес должен быть в диапазоне 1-32")
    # В документации указано 1..64, но рабочие реализации используют до 112 (0x70)
    if not (1 <= read_length <= 112):
        raise ValueError("Длина чтения должна быть в диапазоне 1-112")

    # Разделяем адрес на старший и младший байты
    tadr_h = (start_address >> 8) & 0xFF
    tadr_l = start_address & 0xFF

    # Формируем пакет без контрольной суммы
    packet = [
        0x55,  # Признак начала пакета
        device_address,  # Сетевой адрес
        ~device_address & 0xFF,  # Инверсный сетевой адрес
        0x0C,  # Группа команд: Чтение памяти
        0x01,  # Команда: Чтение оперативной памяти
        0x03,  # LEN: Длина посылаемых данных (всегда 3 для этого запроса)
        tadr_h,  # Старший байт начального адреса
        tadr_l,  # Младший байт начального адреса
        read_length  # Длина считываемого блока
    ]

    # Рассчитываем и добавляем контрольную сумму
    checksum = calculate_checksum(packet)
    packet.append(checksum)

    return bytes(packet)

# --- Пример использования ---

# Адрес нашего счетчика
DEVICE = 1
# Начальный адрес структуры SysPar (для первой системы)
START_ADDR = 0x0000
# Длина чтения, как в проверенной реализации
READ_LEN = 112  # 0x70

# Создаем пакет запроса
request_packet = create_read_request(DEVICE, START_ADDR, READ_LEN)

print(f"Сформированный пакет: {request_packet.hex(' ').upper()}")
print(f"Длина пакета: {len(request_packet)} байт")


# --- Обработка ответа (теоретическая) ---
# После отправки request_packet через serial-порт, вы получите ответ.
# Например, такой (это гипотетический ответ):
# AA 01 FE 0C 01 70 <...112 байт данных...> CS
#
# Для парсинга данных (например, температур) нужно использовать struct.unpack.
# Температуры (4 канала) - это 4*4 = 16 байт, тип float.

# response_data = b'' # Сюда помещаются данные из serial-порта
# if len(response_data) > 7: # Убедимся, что пакет не пустой
#     data_payload = response_data[6:-1] # Извлекаем только полезные данные

#     # Распаковываем первые 4 значения float (16 байт) из данных
#     try:
#         # < - little-endian, 4f - четыре 4-байтных float
#         temperatures = struct.unpack('<4f', data_payload[0:16])
#         print(f"Распакованные температуры: {temperatures}")
#     except struct.error as e:
#         print(f"Ошибка распаковки: {e}. Возможно, получено неверное количество байт.")

```
